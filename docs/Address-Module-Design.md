# Address Module Design Document

## ğŸ“‹ Overview

The Address module is a core component of the CRM system that manages customer addresses. It enables customers to have multiple addresses and provides seamless integration with the Order module for shipping address selection.

## ğŸ—ï¸ Architecture Design

### 1. **Layered Architecture**

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚      Frontend (React + TypeScript) â”‚
â”‚  - AddressList Component            â”‚
â”‚  - AddressService (Class-based)     â”‚
â”‚  - API Integration                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
               â”‚ HTTP/REST
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚      Backend (ASP.NET Core)         â”‚
â”‚  - AddressesController (API Layer) â”‚
â”‚  - AddressService (Business Logic)  â”‚
â”‚  - Address Model (Data Model)        â”‚
â”‚  - AddressDto (Data Transfer)       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
               â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚      Database (SQLite)              â”‚
â”‚  - Addresses Table                  â”‚
â”‚  - Foreign Key: CustomerId          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 2. **Design Patterns**

- **Repository Pattern**: Service layer abstracts data access
- **DTO Pattern**: Separate data transfer objects for API contracts
- **Service Layer Pattern**: Business logic separated from controllers
- **Dependency Injection**: Services injected via constructor

## ğŸ“Š Data Model Design

### Database Schema

```sql
CREATE TABLE Addresses (
    Id INTEGER PRIMARY KEY AUTOINCREMENT,
    CustomerId INTEGER NOT NULL,
    Street TEXT NOT NULL,
    Suburb TEXT NOT NULL,
    Postcode TEXT NOT NULL,
    State TEXT NOT NULL,
    FOREIGN KEY (CustomerId) REFERENCES Customers(Id) ON DELETE CASCADE
);
```

### Entity Relationship

```
Customer (1) â”€â”€â”€â”€â”€â”€< (Many) Address
```

**Key Design Decisions:**
- **One-to-Many Relationship**: One customer can have multiple addresses
- **Cascade Delete**: When a customer is deleted, all their addresses are automatically removed
- **Required Fields**: All address fields are mandatory for data integrity
- **No Address Type**: Simplified design - all addresses are treated equally

## ğŸ”Œ API Design

### RESTful Endpoints

| Method | Endpoint | Description | Response |
|--------|----------|-------------|----------|
| `GET` | `/api/addresses` | Get all addresses | `AddressDto[]` |
| `GET` | `/api/addresses/{id}` | Get address by ID | `AddressDto` |
| `GET` | `/api/addresses/customer/{customerId}` | Get addresses by customer | `AddressDto[]` |
| `POST` | `/api/addresses` | Create new address | `AddressDto` (201) |
| `PUT` | `/api/addresses/{id}` | Update address | `AddressDto` |
| `DELETE` | `/api/addresses/{id}` | Delete address | `204 No Content` |

### DTO Structure

**AddressDto** (Response)
```csharp
{
    Id: int,
    CustomerId: int,
    CustomerName: string,  // Denormalized for display
    Street: string,
    Suburb: string,
    Postcode: string,
    State: string
}
```

**AddressCreateDto** (Request)
```csharp
{
    CustomerId: int,
    Street: string,
    Suburb: string,
    Postcode: string,
    State: string
}
```

**AddressUpdateDto** (Request)
```csharp
{
    Street: string,
    Suburb: string,
    Postcode: string,
    State: string
}
```

**Design Rationale:**
- **CustomerName in DTO**: Denormalized for efficient display without additional queries
- **Separate Create/Update DTOs**: Update doesn't require CustomerId (immutable relationship)
- **No AddressId in Create**: Auto-generated by database

## ğŸ’» Frontend Design

### Component Structure

```
Addresses/
â”œâ”€â”€ index.tsx          # Main container component
â”œâ”€â”€ AddressList.tsx    # List display component
â”œâ”€â”€ AddressService.ts  # Service layer (Class-based)
â””â”€â”€ AddressForm.tsx    # Form component (inline in index.tsx)
```

### Service Architecture

**Unified Service Pattern** (consistent with OrderService):
```typescript
class AddressService {
  async getAll(): Promise<Address[]>
  async getById(id: number): Promise<Address>
  async create(data: AddressCreate): Promise<Address>
  async update(id: number, data: AddressUpdate): Promise<Address>
  async delete(id: number): Promise<void>
  async getCustomers(): Promise<Customer[]>
  async getByCustomer(customerId: number): Promise<Address[]>
}

export const addressService = new AddressService();
```

**Key Design Decisions:**
- **Class-based Service**: Consistent with OrderService pattern
- **Centralized API**: All address APIs in `api.ts`
- **Type Safety**: Full TypeScript typing with interfaces
- **Error Handling**: Service layer handles API errors

### State Management

```typescript
// Component State
- addresses: Address[]        // List of all addresses
- customers: Customer[]       // For dropdown selection
- formData: AddressForm       // Form input state
- editingId: number | null    // Currently editing address ID
- showForm: boolean           // Form visibility
- loading: boolean           // Loading state
```

## ğŸ”„ Business Logic

### Validation Rules

1. **Customer Validation**
   - Customer must exist before creating address
   - CustomerId cannot be changed after creation

2. **Address Field Validation**
   - All fields (Street, Suburb, Postcode, State) are required
   - No format validation (flexible for international addresses)

3. **Delete Constraints**
   - Address can be deleted if not referenced by active orders
   - Cascade delete when customer is deleted

### Service Methods Logic

**GetAllAsync()**
- Includes customer information via JOIN
- Returns flattened DTO with CustomerName

**GetByCustomerIdAsync()**
- Optimized query for customer-specific addresses
- Used in Order form for address selection

**CreateAsync()**
- Validates customer exists
- Creates address and returns with customer name

**UpdateAsync()**
- Only updates address fields (not CustomerId)
- Returns updated address with customer name

**DeleteAsync()**
- Simple delete operation
- Returns boolean for success/failure

## ğŸ”— Integration Points

### 1. **Order Module Integration**

**Address Selection in Order Form:**
```typescript
// OrderForm.tsx
useEffect(() => {
  if (formData.customerId) {
    addressApi.getByCustomer(formData.customerId)
      .then(res => setAddresses(res.data))
      .catch(() => setAddresses([]));
  }
}, [formData.customerId]);
```

**Order Display:**
- Order includes AddressId foreign key
- Address details displayed in OrderCard component
- Address validation in OrderService.CreateAsync()

### 2. **Customer Module Integration**

- Address list filtered by CustomerId
- Customer deletion cascades to addresses
- Customer name displayed in address list

## ğŸ¯ Design Principles

### 1. **Separation of Concerns**
- **Controller**: HTTP handling, request/response
- **Service**: Business logic, validation
- **Model**: Data structure
- **DTO**: API contract

### 2. **Consistency**
- Service pattern matches OrderService
- API structure follows REST conventions
- Error handling consistent across modules

### 3. **Performance**
- Eager loading of customer data (Include)
- Denormalized CustomerName in DTO
- Efficient queries with proper indexing

### 4. **Maintainability**
- Clear naming conventions
- Comprehensive XML documentation
- Type-safe TypeScript interfaces

### 5. **User Experience**
- Inline form editing
- Real-time validation
- Toast notifications for actions
- Loading states

## ğŸ“ˆ Future Enhancements

### Potential Improvements

1. **Address Types**
   - Add `AddressType` enum (Home, Work, Shipping, Billing)
   - Allow setting default address per type

2. **Address Validation**
   - Integration with address validation APIs
   - Format validation for postcodes
   - Geocoding support

3. **Address History**
   - Track address changes over time
   - Audit log for compliance

4. **International Support**
   - Country field
   - Region/Province standardization
   - Multi-language support

5. **Performance Optimization**
   - Pagination for large address lists
   - Caching frequently accessed addresses
   - Lazy loading in address dropdowns

## âœ… Testing Considerations

### Unit Tests
- Service layer business logic
- DTO mapping
- Validation rules

### Integration Tests
- API endpoint testing
- Database operations
- Customer-Address relationship

### E2E Tests
- Address CRUD operations
- Order address selection flow
- Customer deletion cascade

## ğŸ“ Summary

The Address module follows a clean, layered architecture with clear separation of concerns. It integrates seamlessly with the Order and Customer modules while maintaining consistency with the overall system design. The module is designed for extensibility and maintainability, with room for future enhancements as business requirements evolve.

